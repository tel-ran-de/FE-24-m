// https://typescript-exercises.github.io - практика
// https://tproger.ru/translations/course-on-typescript/
// https://typescript-handbook.ru/docs/ts-2



// Самый быстрый способ запустить приложение React/TypeScript
// использовать create-react-app с шаблоном TypeScript:      
// yarn create react-app my-app --template typescript
// или установить в существующий проект:
// yarn add typescript @types/node @types/react @types/react-dom @types/jest
// Подробнее про установку или добавление в проект: https://create-react-app.dev/docs/adding-typescript/



// если вы добавляете typeScript в уже существуете проект, 
// то вам нужно будет ещё отдельно инициализировать tsconfig
// yarn tsc --init
// tsconfig.json это файл конфигурации TypeScript



// Изначально в приложении возникает 2 ошибки:
// 1) В tsconfig нужно отредактировать "jsx" значение, 
// чтобы сказать приложению как ему 
// интерпретировать эти данные jsx - передать их babel(preserve),
// или преобразовать их в react элементы(react)
// по умолчанию у нас preserve, так что просто нужно его раскомментировать

// 2) Следующая ошибка в index.tsx необходимо указать какой тип данных принимает функция
// ReactDOM.createRoot, а именно нужно указать тип данных "as HTMLElement"
// таким образом ошибки решаться




// посмотрим на tsconfig подробнее, он представляет из себя множество настроек
// в зависимости от вашего проекта у вас может быть та или иная конфигурация правил
// на этот конфиг можно смотреть как на своеобразный линтер, при нарушении его правил
// вы будете видеть ошибки в консоли
// постепенно он перестанет вас пугать и вы разберетесь со всем, что вам будет нужно




// В будущем вам будут особенно важны следующие команды
// Они будут нужны для компиляции при yarn build
// "rootDir": "src",
// "outDir": "build"
















// посмотрим на простой пример

function App() {
  return (
    <div>
      <h1>App</h1>
      <StandardComponent 
        title={'Строка'}
        box={5}
        list={["Hello", true, 1, 3, 6]}
      />
    </div>
  );
}

export default App;



export interface StandardComponentProps {
  title: string
  box: number
  list: any[]
}

function StandardComponent({
  title,
  box,
  list,
}: StandardComponentProps) {
  return (
    <div>
      {title}: {box}
      <div>{list[0]}{list[3]}</div>
    </div>
  )
}



// Рассмотрим типы данных
// Подробнее: https://typescript-handbook.ru/docs/ts-2


// Всё, что угодно - any



// Примитивы: 
// 1) string - "Hello, world"
// 2) number - 42
// 3) boolean - true false

// (всегда с маленькой буквы! НЕ String, Number, Boolean - они зарезервированы)



// Массивы: 
// 1) number[] - [1, 2, 3]
// 2) string[] - ["Hello", "world"]
// 3) any[] - ["Hello", true, 1, 3, 6]
// ... и так далее



// Типы переменных:
// let myName: string = "Alice";



// Типизация функций:
// аргументы:
// function greet(name: string) {
//   console.log("Hello, " + name.toUpperCase() + "!!");
// }

// возвращаемое значение:
// function getFavoriteNumber(): number {
//   return 26;
// }



// Типы объектов
// тобы определить тип объекта, мы просто перечисляем его свойства и их типы.

// function printCoord(pt: { x: number; y: number }) {
//   console.log("The coordinate's x value is " + pt.x);
//   console.log("The coordinate's y value is " + pt.y);
// }
// printCoord({ x: 3, y: 7 });

// Если вы не укажете тип, предполагается, что это any.



// Типы объектов также могут указывать, 
// что некоторые или все их свойства являются необязательными.
// Для этого добавьте ? после имени свойства:

// function printName(obj: { first: string; last?: string }) {
//   console.log(obj.first, obj.last);
// }
// printName({ first: "Bob" });
// printName({ first: "Alice", last: "Alisson" })



// Комбинирование типов
// function printId(id: number | string) {
//   console.log("Your ID is: " + id);
// }
// // OK
// printId(101);
// // OK
// printId("202");
// // Error
// printId({ myID: 22342 });




// Псевдонимы типов, ключевое слово type
// type ID = number | string;
// function printId(id: ID) {
//   console.log("Your ID is: " + id);
// }

// type Point = {
//   x: number;
//   y: number;
// };
 
// // Exactly the same as the earlier example
// function printCoord(pt: Point) {
//   console.log("The coordinate's x value is " + pt.x);
//   console.log("The coordinate's y value is " + pt.y);
// }
 
// printCoord({ x: 100, y: 100 });




// Интерфейсы, ключевое слово interface
// interface Point {
//   x: number;
//   y: number;
// }
 
// function printCoord(pt: Point) {
//   console.log("The coordinate's x value is " + pt.x);
//   console.log("The coordinate's y value is " + pt.y);
// }
 
// printCoord({ x: 100, y: 100 });

// Интерфейсы отличаются от псевдонимов тем, 
// что они очевидно расширяемы

// interface Animal {
//   name: string
// }
// interface Bear extends Animal {
//   honey: boolean
// }
// const bear = getBear() 
// bear.name
// bear.honey


// Псевдонимы тоже можно расширить, но это не удобно
// type Animal = {
//   name: string
// }
// type Bear = Animal & { 
//   honey: boolean 
// }
// const bear = getBear();
// bear.name;
// bear.honey;


// И самое серьёзное отличие в том, 
// что псевдоним (type) нельзя изменить после создания
// type Window = {
//   title: string
// }

// type Window = {
//   box: number
// }
// Error: Duplicate identifier 'Window'.


// Добавление новых полей в существующий интерфейс
// interface Window {
//   title: string
// }

// interface Window {
//   box: number
// }






// Утверждения типа, ключевое слово as
// const myDiv = document.getElementById("div") as HTMLElement;
// const myCanvas = document.getElementById("main_canvas") as HTMLCanvasElement;




// Буквенные типы
// В дополнение к общим типам string и number, 
// мы можем ссылаться на определенные строки и числа.
// let x: "hello" = "hello";
// но это не особенно имеет смысл, правда? но взгляните на пример ниже

// function printText(s: string, alignment: "left" | "right" | "center") {
//   // ...
// }
// printText("Hello, world", "left");
// printText("G'day, mate", "centre");
// ERROR Argument of type '"centre"' is not assignable to parameter of type '"left" | "right" | "center"'.



// Типы числовых литералов работают так же:
// function compare(a: string, b: string): -1 | 0 | 1 {
//   return a === b ? 0 : a > b ? 1 : -1;
// }




// Конечно, вы можете комбинировать их с небуквенными типами:

// interface Options {
//   width: number;
// }
// function configure(x: Options | "auto") {
//   // ...
// }
// configure({ width: 100 });
// configure("auto");
// configure("automatic");
// ERROR Argument of type '"automatic"' is not assignable to parameter of type 'Options | "auto"'.


// boolean на самом деле является просто 
// псевдонимом для объединения true | false







// null и undefined
// function doSomething(x: string | null) {
//   if (x === null) {
//     // do nothing
//   } else {
//     console.log("Hello, " + x.toUpperCase());
//   }
// }



















// Беглый обзор

// 1. Типы переменных
// Number
// Все числовые переменные в TypeScript существуют в виде числа с плавающей запятой. 
// Числовой тип получают даже двоичные и шестнадцатеричные числа:

// let num: number = 0.222;
// let hex: number = 0xbeef;
// let bin: number = 0b0010;


// String
// Как и другие языки, TypeScript использует тип String для хранения текстовой информации:
// let str: string = 'Hello World!';

// Можно создавать и многострочные переменные, 
// а также в строки можно вставлять выражения, если выделить строку символами ``:

// let multiStr: string = `Двухстрочная
// переменная`
// let expression = 'Новое выражение'

// let expressionStr: string = `Выражение str: ${ expression }`


// Boolean
// Куда же без одного из основных типов данных:
// let boolFalse: boolean = false;
// let boolTrue: boolean = true;




// 2. Присвоение типов
// Основной способ присвоения типа переменной — 
// написание его после самого имени переменной через символ :

// Одиночный тип переменной
// Простой пример, где присваивается значение переменной типа String:
// let str: string = 'Hello World'
// Такой способ действителен для всех типов данных.

// Мультитип переменной
// Переменной можно присваивать несколько типов, перечисляя их через оператор |

// let multitypeVar: string | number = 'String'
// multitypeVar = 20

// В коде выше переменной назначается два типа: строчный и численный. 
// Теперь переменной можно присваивать как текстовые данные, так и числовые.




// 3. Проверка типов
// Ниже будут описаны два основных (на деле их существует больше) 
// способа проверки типа переменной.

// Typeof
// Команда typeof работает только с базовыми типами данных. 
// Это означает, что эта команда может определить только типы, описанные выше.

// let str: string = 'Hello World!'
// if(typeof str === "number"){
//  console.log('Str — это число')
// } else {
//  console.log('Str — это не число')
// }

// В коде выше создаётся переменная типа String, а потом проверяется, 
// является ли эта переменная числом (что, естественно, всегда будет возвращать false).

// Instanceof
// Это оператор, который работает почти так же, как typeof. 
// Отличие только в том, что это оператор может определять не только базовые типы, 
// но и собственные.

// class Human {
//  name: string;
//  constructor(data: string) {
//   this.name = data;
//  }
// }

// let human = new Human('Gabriel')

// if(human instanceof Human){
//  console.log(`${human.name} человек`)
// }
// В коде выше создаётся собственный тип, 
// а потом инициализируется переменная этого типа. 
// Далее этот тип переменной сравнивается с типом Human, 
// что, в данном случае, возвращает true.




// 4. Тип Assertions
// Иногда приходится преобразовывать (кастовать) переменную одного типа в другой тип. 
// Особенно часто это случается, когда переменную типа any (или другого произвольного типа) 
// нужно передать в функцию, которая принимается аргумент определённого типа.

// Существует много решений этой задачи, но ниже будут описано два самых популярных из них.

// Ключевое слово as
// Чтобы кастовать переменную, нужно после оператора as 
// написать тип, в который переводится переменная.

// let str: any = 'Текстовая переменная'
// let strLength = (str as string).length
// В этом коде текстовая переменная str кастуется в тип String, 
// а поэтому можно использовать параметр length (это сработает и без кастования, 
//   если есть соответствующее разрешение в настройках TSLINT).

// Оператор <>
// Выполняет абсолютно такую же работу, что и ключевое слово as.

// let str: any = 'Текстовая переменная'
// let strLength = (<string>str).length
// // Этот код работает идентично предыдущему — разница только синтаксическая.




// 5. Массивы
// Создание массива

// Используя [] Можно создать массив, написав после типа элемента оператор [], 
// тем самым обозначив эту переменную как массив:

// let strings: string[] = ['Hello', 'World', '!']
// Этот код создает массив элементов String, содержащий 3 разных элемента.



// Используя дженерики
// Создать массив можно с помощью дженерик-типа (обобщённого типа), 
// написав Array<Type>:

// let numbers: Array<number> = [1, 2, 3, 4, 5]
// Этот код создаёт числовой массив, содержащий 5 элементов.

// Мультитипные массивы
// Кроме того, здесь можно создавать массивы 
// с элементами нескольких разных типов. 
// Перечислять типы нужно через оператор |

// let stringsAndNumbers: (string | number)[] = ['Age', 20]
// В этом коде создаётся массив, который может содержать 
// как текстовые переменные, так и числовые.


// Многомерные массивы
// TypeScript поддерживает многомерные массивы — 
// можно сохранять массивы в других массивах. 
// Создать такой массив можно через множественный оператор [].

// let numbersArray: number[][] = [[1,2,3,4,5], [6,7,8,9,10]]
// Тут создаётся массив, элементами которого являются другие массивы, 
// которые, в свою очередь, содержат числа.





// 6. Кортежи

// Кортежи похожи на массивы с одним ключевым отличием. 
// В кортежах можно указать тип каждого конкретного элемента. 
// Нужно перечислить все типы в квадратных скобках, 
// тем самым присвоив их каждой позиции.

// let exampleTuple: [number, string] = [20, 'строка'];
// В этом примере создаётся кортеж c числом на позиции 0
 // и текстовой переменной на позиции 1.

// Внимание: При некорректном присвоении элемента будет выбрасываться исключение.

// Пример того, как делать не нужно:
// let exampleTuple: [string, number] = [20, 'https://tproger.ru'];





// 7. Enum (перечисление)

// В TypeScript, как и в других объектно-ориентированных языках, 
// существуют Enum (перечисления). 
// Они позволяют определять именованные константы. 
// В этом языке так же существует возможность создавать текстовые и числовые константы. 
// Определяются перечисления ключевым словом enum.

// Числовые константы
// Ниже идёт пример числового перечисления, 
// где каждому значению сопоставляется число.

// enum State {
//  Playing = 0,
//  Paused = 1,
//  Stopped = 2
// }

// Такое же перечисление (где первое значение равно 0, второе — 1 и т. д.) 
// можно добиться и таким кодом:

// enum State {
//  Playing,
//  Paused,
//  Stopped
// }


// Текстовые константы
// Объявление текстового перечисления идентично числовому, 
// только вместо числовых значений указываются текстовые:
// enum State {
//  Playing = 'PLAYING',
//  Paused = 'PAUSED',
//  Stopped = 'STOPPED'
// }





// 7. Объекты

// Объект в TypeScript является сущностью, 
// которая содержит набор пар ключ-значение. 
// Значение может быть переменной, массивом или даже функцией. 
// Объект рассматривается как отдельный тип переменной, 
// не относящийся к примитивным.

// Создаётся объект в фигурных скобках:
// const human = {
//  firstName: 'Frank',
//  age: 32,
//  height: 185
// };
// В коде выше создаётся объект human с 3 разными парами ключ-значение.

// А вот как создавать функцию в объектах:
// const human = {
//  firstName: 'Старец',
//  age: 32,
//  height: 185,
//  greet: function(){
//   console.log("Приветствую тебя, путник!")
//  }
// };




// 7. Собственные типы

// В TypeScript есть возможность создавать свои типы, 
// называемые алиасами (англ. alias). 
// Создаётся собственный тип через ключевое слово type.

// type Human = {
//   firstName: string, 
//   age: number, 
//   height: number
// }

// В примере выше создаётся собственный тип Human, 
// содержащий 3 разных свойства. 
// Пример создания объекта типа Human:

// const human: Human = {
//   firstName: 'Franz', 
//   age: 32, 
//   height: 185
// }






// 7. Аргументы функций и возвращаемые типы

// В TypeScript можно передавать тип аргумента функций 
// и указывать тип возвращаемого значения. Как это выглядит:

// function printState(state: State): void {
//  console.log(`The song state is ${state}`)
// }

// function add(num1: number, num2: number): number {
//  return num1 + num2
// }

// В примере выше создаются две функции, 
// обе имеют аргументы с определёнными типами. 
// Во второй функции так же определён тип возвращаемого значения.

// Вызываются функции точно так же, как и в обычном JavaScript, 
// но компилятор проверяет правильность передаваемых параметров,
// и в случае чего выводит ошибку.
// console.log(add(2,5))
// add(1) // "Error to few parameters"
// add(5, '2') // "Error the second argument must be type number"




// 8. Опциональные (необязательные) аргументы

// Аргумент функции можно сделать необязательным, 
// поставив после него оператор ? 

// Вот как это выглядит:
// function printName(firstName: string, lastName?: string) {
//  if (lastName)
//   console.log(`Firstname: ${firstName}, Lastname: ${lastName}`);
//  else
//   console.log(`Firstname: ${firstName}`);
// }
// В примере выше параметр lastName является необязательным, 
// и если он не будет передан, компилятор не выдаст ошибку.

// printName('Gabriel', 'Tanner')
// printName('Gabriel')
// Эти две строки будут исполнены без ошибок.






// 9. Значения по умолчанию
// Для аргументов функции можно назначать значение по умолчанию. 
// Это значение будет присваиваться аргументу тогда, 
// когда при вызове функции значение самого аргумента не было передано. 

// Пример:
// function printName(firstName: string, lastName: string = 'Tanner') {
//  console.log(`Firstname: ${firstName}, Lastname: ${lastName}`);
// }
// В коде выше аргументу lastName присваивается значение по умолчанию, 
// и теперь его не нужно передавать каждый раз при вызове функции 
// (если не нужно передать отличающееся значение).






// 10. Интерфейсы
// Интерфейсы содержат свойства и методы кастомного типа, 
// но не содержат их реализацию. 
// Реализацию берёт на себя класс, реализующий интерфейс. 

// Для ясности вот пример:
// interface Person {
//  name: string
// }
// const person: Person = { name: 'Gabriel' }
// const person2: Person = {names: 'Gabriel'} // Тип Person не присваивается
// В примере выше в первом свойстве реализуется интерфейс Person. 
// Попытка реализации интерфейса в переменной person2 выбросит исключение.





// 10. Опциональные (необязательные) свойства
// При реализации интерфейса можно реализовывать не все его свойства. 
// Чтобы сделать свойство необязательным, после имени свойства нужно поставить оператор ?

// Пример:
// interface Person {
//  name: string
//  age?: number
// }
// const person: Person = {name: 'Frank', age: 28}
// const person2: Person = {name: 'Gabriel'}
// В этом коде создаются два свойства: обычное и необязательное. 
// Теперь при реализации интерфейса в переменной person2 исключение вызываться не будет.






// 10. Read-only свойства
// Такие свойства используются тогда, 
// когда нужно изменять свойство только в самом начале, при реализации, 
// а потом свойство становится доступным только для чтения. 
// Для этого используйте ключевое слово readonly.

// interface Person {
//  name: string
//  readonly id: number
//  age?: number
// }
// const person: Person = {name: 'Gabriel', id: 3127831827}
// person.id = 200 // Изменить значение уже не получится




// 12. Generic
// Дженерики (англ. generics) позволяют создавать компоненты, 
// которые совместимы с большим количеством типов, а не только с одним. 
// Это делает компоненты более «открытыми».

// Возможно у вас возникнет вопрос: 
// а почему бы не использовать тип any для взятия сразу нескольких типов? 
// Рассмотрев пример ниже, можно это легко понять.

// Допустим, нужно создать какую-нибудь функцию, 
// которая возвращает переданный ей параметр:

// function dummyFun(arg: any): any {
//  return arg;
// }
// Хоть any и является обобщающим типом, у него есть одно отличие. 
// При использовании типа any не получится узнать оригинальный тип передаваемой переменной.

// Ниже приведён пример того, как можно это реализовать с помощью дженерика:
// function dummyFun(arg: T): T {
//  return arg
// }
// В этом коде используется generic-параметр T, 
// тип которого можно будет захватить и в дальнейшем использовать.















// Домашнее задание
// Создайте приложение create-react-app + typescript
// Приложение должно выводить следующую структуру данных 
// Информацию о пользователе
// const user = {
//   name: 'Brad',
//   surname: 'Tomik',
//   age: 31,
// }
// Информацию о погоде
// const weather = {
//   light: 'Dark',
//   sky: 'Clouds',
//   cold: false,
//   temperature: 20,
// }
// Информацию о городе
// const city = {
//   light: 'Ljubljana',
//   country: 'Slovenia',
//   population: 250000,
//   europe: true,
// }

// выводите данные на трех разных страницах (/user, weater/, city), реализуйте react router
// имейте ввиду, что данные могут различатся 
// для тестирования сделайте по два экземляра данных
// первый с неверными типами данных
// второй просто с другими данными

// используйте максимально инструментарий типизирования, который вы освоили

// 1) Для props используйте interface и его расширение (можно сделать так, 
// чтобы страна подставлялась в зависимости от города, 
// для этого можно захардкодить несколько стран-городов в условных операторах)
// расширяйте интерфейс уже непосредственно на странице /city

// 2) Используйте типизацию функций как аргументов, так и возвращаемых значений (для этого напишите функцию которая будет 
// принимать name и surname и возвращать полное имя и отображайте fullname)

// 3) Используйте буквенные типы (условие, чтобы город всегда был в европе),
// а так же комбинирование типов совместно с псевдонимами (europe 
// может быть true или 'yes' и соотвественно иметь псевдоним)