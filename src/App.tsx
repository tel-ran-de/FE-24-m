// https://typescript-handbook.ru/docs/ts-4/




// 1) Тип функции в форме выражения (function type expressions)

// function greeter(fn: (a: string) => void) {
// 	// Выражение (a: string) => void означает 
// 	// "функция с одним параметром a типа string, которая ничего не возвращает"
// 	// eсли тип параметра не указан, он будет иметь значение any.
//   fn('Hello, World')
// }


// function printToConsole(s: string) {
//   console.log(s)
// }
// greeter(printToConsole)



// для типа функции можно использовать синоним
// type GreetFn = (a: string) => void

// function greeter(fn: GreetFn) {
//   fn('Hello, World')
// }
// function printToConsole(s: string) {
//   console.log(s)
// }
// greeter(printToConsole)




// 2) Сигнатуры вызова (call signatures)

// В JS функции, кроме того, что являются вызываемыми (callable), могут иметь свойства. 
// Однако, тип-выражение не позволяет определять свойства функции. 
// Для описания вызываемой сущности (entity), обладающей некоторыми свойствами, 
// можно использовать сигнатуру вызова (call signature) в объектном типе:

// type DescFn = {
//   description: string,
//   (someArg: number): boolean
// }

// // Логическое значение (someArg: number): в DescFn означает, 
// // что любая функция, которая должна имитировать DescFn, должна:

// // Иметь один аргумент с типом "число"
// // Тип возвращаемого значения должен быть логическим

// // Если он соответствует этим условиям, 
// // теперь он имеет право использовать свойства (объекта)DescFn.


// function doSomething(fn: DescFn) {
//   console.log(`Значением, возвращаемым ${fn.description} является ${fn(6)}`)
// }

// const callable = (num: number) => {
//     return num > 5;
// }
// callable.description = "Number is greater than 5";

// doSomething(callable)






// 3) Сигнатуры конструктора (construct signatures)

// функции могут вызываться с ключевым словом new
// TS считает такие функции конструкторами, поскольку они
// используются для создания объектов. 

// Для определения типов таких функций используется сигнатура конструктора:

// interface ComesFromString {
//     name: string;
// }

// interface StringConstructable {
//     new(n: string): ComesFromString;
// }

// class MadeFromString implements ComesFromString {
//     constructor (public name: string) {
//         console.log('ctor invoked');
//     }
// }

// function makeObj(n: StringConstructable) {
//     return new n('hello!');
// }

// console.log(makeObj(MadeFromString));

// // Это создает фактическое ограничение для того, что вы можете вызывать makeObj:

// class Other implements ComesFromString {
//     constructor (public name: string, count: number) {
//     }
// }

// makeObj(Other); // Error! Other's constructor doesn't match StringConstructable




// 4) Общие функции или функции-дженерики

// Часто тип данных, возвращаемых функцией, 
// зависит от типа передаваемого функции аргумента 
// или же два типа возвращаемых функцией значений зависят друг от друга. 

// Рассмотрим функцию, возвращающую первый элемент массива:
// 
// function firstElement(arr: any[]) {
//   return arr[0]
// }

// Функция делают свою работу, но,
// типом возвращаемого значения является any. 
// Было бы лучше, если бы функция возвращала тип элемента массива.


// В TS общие типы или дженерики (generics) 
// используются для описания связи между двумя значениями. 

// Это делается с помощью определения параметра Type в сигнатуре функции:

// function firstElement<Type>(arr: Type[]): Type {
//   return arr[0]
// }

// Добавив параметр Type и использовав его в двух местах, 
// мы создали связь между входящими данными функции (массивом) 
// и ее выходными данными (возвращаемым значением). 

// Теперь при вызове функции возвращается более конкретный тип:

// // `s` имеет тип `string`
// const s = firstElement(['a', 'b', 'c'])
// // `n` имеет тип `number`
// const n = firstElement([1, 2, 3])


















// дженерики подробнее 1.

// Создадим функцию identity, которая 
// будет возвращать переданное ей значение:

// function identity(arg: number): number {
//   return arg
// }

// Для того, чтобы сделать эту функцию более универсальной, 
// можно использовать тип any:

// function identity(arg: any): any {
//   return arg
// }

// Однако, при таком подходе мы не будем знать 
// тип возвращаемого функцией значения.

// Нам нужен какой-то способ перехватывать тип аргумента 
// для обозначения с его помощью типа возвращаемого значения. 
// Для этого мы можем воспользоваться переменной типа, 
// специальным видом переменных, которые работают с типами, а не со значениями:

// function identity<Type>(arg: Type): Type {
//   return arg
// }


// Мы используем переменную Type как для типа передаваемого функции аргумента, 
// так и для типа возвращаемого функцией значения.

// Такие функции называют общими (дженериками), 
// поскольку они могут работать с любыми типами.

// Мы можем вызывать такие функции двумя способами. 
// Первый способ заключается в передаче всех аргументов, включая аргумент типа:

// const output = identity<string>('myStr')

// let output: string
// В данном случае принимаемым и возвращаемым типами является строка.

// Второй способ заключается в делегировании типизации компилятору:

// const output = identity('myStr')





// let output: string
// Второй способ является более распространенным. 
// Однако, в более сложных случаях может потребоваться 
// явное указание типа, как в первом примере.







// дженерики подробнее 2.
// Работа с переменными типа в дженериках

// Что если мы захотим выводить в консоль 
// длину аргумента arg перед его возвращением?

// function loggingIdentity<Type>(arg: Type): Type {
//   // Свойства 'length' не существует в типе 'Type'
//   return arg
// }

// Мы получаем ошибку, поскольку переменные типа 
// указывают на любой тип, следовательно, аргумент arg 
// может не иметь свойства length, например, 
// если мы передадим в функцию число.

// Изменим сигнатуру функции таким образом, 
// чтобы она работала с массивом Type:

// function loggingIdentity<Type>(arg: Type[]): Type[] {
//   console.log(arg.length)
//   return arg
// }

// Теперь наша функция стала дженериком, 
// принимающим параметр Type и аргумент arg, 
// который является массивом Type, и возвращает массив Type. 
// Если мы передадим в функцию массив чисел, то получим массив чисел.

// Мы можем сделать тоже самое с помощью такого синтаксиса:

// function loggingIdentity<Type>(arg: Array<Type>): Array<Type> {
//   console.log(arg.length)
//   return arg
// }




// дженерики подробнее 3.
// Общие типы
// Тип общей функции (функции-дженерика) похож на тип обычной функции, 
// в начале которого указывается тип параметра:

// function identity<Type>(arg: Type): Type {
//   return arg
// }

// const myIdentity: <Type>(arg: Type) => Type = identity

// Мы можем использовать другое название для параметра общего типа:

// function identity<Type>(arg: Type): Type {
//   return arg
// }

// const myIdentity: <Input>(arg: Input) => Input = identity



// Мы также можем создавать общие типы в виде 
// сигнатуры вызова типа объектного литерала:

// function identity<Type>(arg: Type): Type {
//   return arg
// }

// const myIdentity: { <Type>(arg: Type): Type } = identity

// Это приводит нас к общему интерфейсу:
// interface GenericIdentityFn {
//   <Type>(arg: Type): Type
// }

// function identity<Type>(arg: Type): Type {
//   return arg
// }

// const myIdentity: GenericIdentityFn = identity




// Для того, чтобы сделать общий параметр 
// видимым для всех членов интерфейса, 
// его необходимо указать после названия интерфейса:

// interface GenericIdentityFn<Type> {
//   (arg: Type): Type
// }

// function identity<Type>(arg: Type): Type {
//   return arg
// }

// const myIdentity: GenericIdentityFn<number> = identity




// дженерики подробнее 4. - Общие классы

// Общий класс имеет такую же форму, что и общий интерфейс:
// class GenericNumber<NumType> {
//   zeroValue: NumType
//   add: (x: NumType, y: NumType) => NumType
// }

// const myGenericNum = new GenericNumber<number>()

// myGenericNum.zeroValue = 0
// myGenericNum.add = (x, y) => x + y


// В случае с данным классом мы не ограничены числами. 
// Мы вполне можем использовать строки или сложные объекты:
// const stringNumeric = new GenericNumber<string>()
// stringNumeric.zeroValue = ''
// stringNumeric.add = (x, y) => x + y
// console.log(stringNumeric.add(stringNumeric.zeroValue, 'test'))



// Класс имеет две стороны с точки зрения типов: 
// статическую сторону и сторону экземпляров. 
// Общие классы являются общими только для экземпляров. 
// Это означает, что статические члены класса 
// не могут использовать тип параметра класса.



// дженерики подробнее 5. - Ограничения дженериков

// Иногда возникает необходимость в создании дженерика, 
// работающего с набором типов, когда мы имеем некоторую информацию
// о возможностях, которыми будет обладать этот набор. 

// В нашем примере loggingIdentity мы хотим получать доступ 
// к свойству length аргумента arg, но компилятор знает, 
// что не каждый тип имеет такое свойство, поэтому не позволяет нам делать так:

// function loggingIdentity<Type>(arg: Type): Type {
//   console.log(arg.length)
//   // Property 'length' does not exist on type 'Type'.
//   return arg
// }

// Мы хотим, чтобы функция работала с любым типом, 
// у которого имеется свойство length. 
// Для этого мы должны создать ограничение типа.

// Нам необходимо создать интерфейс, описывающий ограничение. 
// В следующем примере мы создаем интерфейс с единственным свойством length 
// и используем его с помощью ключевого слова extends для применения органичения:

// interface Lengthwise {
//   length: number
// }

// function loggingIdentity<Type extends Lengthwise>(arg: Type): Type {
//   console.log(arg.length)
//   // Теперь мы можем быть увереными в существовании свойства `length`
//   return arg
// }

// Поскольку дженерик был ограничен, он больше не может работать с любым типом:
// loggingIdentity(3)
// Аргумент типа 'number' не может быть присвоен параметру типа 'Lengthwise'

// Мы должны передавать ему значения, отвечающие всем установленным требованиям:
// loggingIdentity({ length: 10, value: 3 })




// дженерики подробнее 6. - Ограничения дженериков

// Мы можем определять типы параметров, ограниченные другими типами параметров.

// В следующем примере мы хотим получать свойства объекта по их названиям. 
// При этом, мы хотим быть уверенными в том, что не извлекаем несуществующих свойств. 
// Поэтому мы помещаем ограничение между двумя типами:

// function getProperty<Type, Key extends keyof Type>(obj: Type, key: Key) {
//   return obj[key]
// }
// const x = { a: 1, b: 2, c: 3, d: 4 }

// console.log(getProperty(x, 'a'));
// getProperty(x, 'm')
// Argument of type '"m"' is not assignable to parameter of type '"a" | "b" | "c" | "d"'.





// дженерики подробнее 7. - Использование типов класса в дженериках
// При создании фабричных функций с помощью дженериков, 
// необходимо ссылаться на типы классов через их функции-конструкторы. 

// Например:
// function create<Type>(c: { new (): Type }): Type {
//   return new c()
// }

// // В более сложных случаях может потребоваться использование 
// // свойства prototype для вывода и ограничения отношений 
// // между функцией-конструктором и стороной экземляров типа класса:

// class BeeKeeper {
//   hasMask: boolean
// }

// class ZooKeeper {
//   nametag: string
// }

// class Animal {
//   numLegs: number
// }

// class Bee extends Animal {
//   keeper: BeeKeeper
// }

// class Lion extends Animal {
//   keeper: ZooKeeper
// }

// function createInstance<A extends Animal>(c: new () => A): A {
//   return new c()
// }

// createInstance(Lion).keeper.nametag
// createInstance(Bee).keeper.hasMask
// Данный подход часто используется в миксинах или примесях.





// дженерики подробнее 8. - Оператор типа keyof

// Оператор keyof "берет" объектный тип и возвращает строковое 
// или числовое литеральное объединение его ключей:

// type Point = { x: number; y: number }
// type P = keyof Point
// // type P = keyof Point

// Если типом сигнатуры индекса (index signature) типа 
// является string или number, keyof возвращает эти типы:
// type Arrayish = { [n: number]: unknown }
// type A = keyof Arrayish
// // type A = number

// type Mapish = { [k: string]: boolean }
// type M = keyof Mapish
// // type M = string | number





// дженерики подробнее 9. - Оператор типа typeof

// JS предоставляет оператор typeof, 
// который можно использовать в контексте выражения:
// console.log(typeof 'Привет, народ!') // string

// В TS оператор typeof используется в контексте 
// типа для ссылки на тип переменной или свойства:

// const s = 'привет'
// const n: typeof s
// const n: string

// В сочетании с другими операторами типа мы можем 
// использовать typeof для реализации нескольких паттернов. 

// Например, давайте начнем с рассмотрения предопределенного типа ReturnType<T>. 
// Он принимает тип функции и производит тип возвращаемого функцией значения:

// type Predicate = (x: unknown) => boolean
// type K = ReturnType<Predicate>
// type K = boolean

// Если мы попытаемся использовать название функции 
// в качестве типа параметра ReturnType, то получим ошибку:
// function f() {
//   return { x: 10, y: 3 }
// }
// type P = ReturnType<f>
// 'f' является ссылкой на значение, но используется как тип. 
// Возможно, вы имели ввиду 'typeof f'

// Запомните: значения и типы - это не одно и тоже. 
// Для ссылки на тип значения f следует использовать typeof:

// function f() {
//   return { x: 10, y: 3 }
// }
// type P = ReturnType<typeof f>
// // type P = { x: number, y: number }


// Ограничения
// TS ограничивает виды выражений, на которых можно использовать typeof.

// typeof можно использовать только в отношении идентификаторов 
// (названий переменных) или их свойств. 
// Это помогает избежать написания кода, который не выполняется:
// // Должны были использовать ReturnType<typeof msgbox>, но вместо этого написали
// const shouldContinue: typeof msgbox('Вы уверены, что хотите продолжить?')
// // ',' expected

// закончили с подробностями дженериков











// 4.1) Предположение типа

// Мы можем использовать несколько параметров типа. 
// Например, самописная версия функции map может выглядеть так:

// function map<Input, Output>(
//   arr: Input[],
//   func: (arg: Input) => Output
// ): Output[] {
//   return arr.map(func)
// }

// // Типом `n` является `string`,
// // а типом `parsed` - `number[]`
// const parsed = map(['1', '2', '3'], (n) => parseInt(n))

// // В приведенном примере TS может сделать вывод 
// // относительно типа Input на основе переданного string[], 
// // а относительно типа Output на основе возвращаемого number.








// 4.2) Ограничения

// Ограничение используется для ограничения типов, принимаемых параметром типа.

// Реализуем функцию, возвращающую самое длинное из двух значений. 
// Для этого нам потребуется свойство length, которое будет числом. 
// Мы ограничим параметр типа типом number с помощью ключевого слова extends:


// function longest<Type extends { length: number }>(a: Type, b: Type) {
//   if (a.length >= b.length) {
//     return a
//   } else {
//     return b
//   }
// }




// // Типом `longerArr` является `number[]`
// const longerArr = longest([1, 2], [1, 2, 3])

// // Типом `longerStr` является `string`
// const longerStr = longest('alice', 'bob')

// // Ошибка! У чисел нет свойства `length`
// const notOK = longest(10, 100)

// Мы позволяем TS предполагать тип значения, возвращаемого из функции longest.

// Поскольку мы свели Type к { length: number }, 
// то получили доступ к свойству length параметров a и b. 
// Без ограничения типа у нас бы не было такого доступа, 
// потому что значения этих свойств могли бы иметь другой тип - без длины.

// Типы longerArr и longerStr были выведены на основе аргументов. 
// Запомните, дженерики определяют связь между двумя и более значениями одного типа!

// Наконец, как мы и ожидали, вызов longest(10, 100) отклоняется, 
// поскольку тип number не имеет свойства length.




// 4.3) Работа с ограниченными значениями

// Вот пример распространенной ошибки, возникающей при работе с ограничениями дженериков:

// function minLength<Type extends { length: number }>(
//   obj: Type,
//   min: number
// ): Type {
//   if (obj.length >= min) {
//     return obj
//   } else {
//     return { length: min }
//   }
// }

// Тип '{ length: number; }' не может быть присвоен типу 'Type'.

// Type сведен к { length: number }, и функция возвращает либо Type, 
// либо значение, совпадающее с ограничением. 

// Проблема состоит в том, что функция может вернуть объект, 
// идентичный тому, который ей передается, 
// а не просто объект, совпадающий с ограничением. 

// Если бы во время компиляции не возникло ошибки, 
// мы могли бы написать что-то вроде этого:

// `arr` получает значение `{ length: 6 }`
// const arr = minLength([1, 2, 3], 6)
// и ломает приложение, поскольку массивы
// имеют метод `slice`, но не возвращаемый объект!
// console.log(arr.slice(0))



// 4.4) Определение параметров типа

// Обычно, TS делает правильные выводы относительно 
// типов аргументов в вызове дженерика, но так бывает не всегда. 

// Допустим, мы реализовали такую функцию для объединения двух массивов:

// function combine<Type>(arr1: Type[], arr2: Type[]): Type[] {
//   return arr1.concat(arr2)
// }

// При обычном вызове данной функции 
// с несовпадающими по типу массивами возникает ошибка:

// const arr = combine([1, 2, 3], ['привет'])
// Type 'string' is not assignable to type 'number'.

// Однако, мы можем вручную определить Type, и тогда все будет в порядке:

// const arr = combine<string | number>([1, 2, 3], ['привет'])





// 5) Руководство по написанию хороших функций-дженериков
// 5.1) Используйте типы параметра без ограничений

// Рассмотрим две похожие функции:

// function firstElement1<Type>(arr: Type[]) {
//   return arr[0] // number
// }

// function firstElement2<Type extends any[]>(arr: Type) {
//   return arr[0] // any
// }

// // a: number (хорошо)
// const a = firstElement1([1, 2, 3])
// // b: any (плохо)
// const b = firstElement2([1, 2, 3])

// Предполагаемым типом значения, 
// возвращаемого функцией firstElement1 является Type, 
// а значения, возвращаемого функцией firstElement2 - any. 

// Это объясняется тем, что TS разрешает (resolve) выражение arr[0] 
// с помощью ограничения типа вместо того, 
// чтобы ждать разрешения элемента после вызова функции.

// ! Правило: по-возможности, используйте параметры типа без ограничений.



// 5.2) Используйте минимальное количество типов параметра

// Рассмотрим две похожие функции:

// function filter1<Type>(arr: Type[], func: (arg: Type) => boolean): Type[] {
//   return arr.filter(func)
// }

// function filter2<Type, Func extends (arg: Type) => boolean>(
//   arr: Type[],
//   func: Func
// ): Type[] {
//   return arr.filter(func)
// }


// Во втором случае мы создаем параметр типа Func, 
// который не связывает значения. 
// Это означает, что при вызове функции 
// придется определять дополнительный аргумент типа

// ! Правило: всегда используйте минимальное количество параметров типа.




// 5.3) Типы параметра должны указываться дважды

// Иногда мы забываем, что функция не обязательно должна быть дженериком:

// function greet<Str extends string>(s: Str) {
//   console.log(`Привет, ${s}!`)
// }

// greet('народ')


// // Вот упрощенная версия данной функции:

// function greet(s: string) {
//   console.log(`Привет, ${s}!`)
// }

// Запомните, параметры типа предназначены 
// для связывания типов нескольких значений.

// ! Правило: если параметр типа появляется 
// в сигнатуре функции только один раз, 
// то, скорее всего, он вам не нужен.




// Итого
// * используйте параметры типа без ограничений
// * используйте минимальное количество параметров типа
// * дженерик если параметр типа не один






// 6) Опциональные параметры

// Функции в JS могут принимать произвольное количество аргументов. 
// Например, метод toFixed принимает опциональное количество цифр после запятой:

// function fn(n: number) {
//   console.log(n.toFixed()) // 0 аргументов
//   console.log(n.toFixed(3)) // 1 аргумент
// }


// Мы можем смоделировать это в TS, 
// пометив параметр как опциональный с помощью ?:

// function f(x?: number) {
//   // ...
// }
// f() // OK
// f(10) // OK

// Несмотря на то, что тип параметра определен как number, 
// параметр x на самом деле имеет тип number | undefined, 
// поскольку неопределенные параметры в JS получают значение undefined.

// Мы также можем указать "дефолтный" параметр (параметр по умолчанию):

// function f(x = 10) {
//   // ...
// }
// Теперь в теле функции f параметр x будет иметь тип number, 
// поскольку любой аргумент со значением undefined будет заменен на 10. 
// Обратите внимание: явная передача undefined означает "отсутствующий" аргумент.
// declare function f(x?: number): void
// OK
// f()
// f(10)
// f(undefined)



// 6.1) Опциональные параметры в функциях обратного вызова

// При написании функций, вызывающих "колбеки", легко допустить такую ошибку:

// function myForEach(arr: any[], callback: (arg: any, index?: number) => void) {
//   for (let i = 0; i < arr.length; i++) {
//     callback(arr[i], i)
//   }
// }


// Указав index?, мы хотим, чтобы оба этих вызова были легальными:

// myForEach([1, 2, 3], (a) => console.log(a))
// myForEach([1, 2, 3], (a, i) => console.log(a, i))


// В действительности, это означает, что колбек 
// может быть вызван с одним аргументом. 
// Другими словами, определение функции говорит, 
// что ее реализация может выглядеть так:

// function myForEach(arr: any[], callback: (arg: any, index?: number) => void) {
//   for (let i = 0; i < arr.length; i++) {
//     callback(arr[i])
//   }
// }

// Поэтому попытка вызова такой функции приводит к ошибке:

// myForEach([1, 2, 3], (a, i) => {
//   console.log(i.toFixed())
//   // Object is possibly 'undefined'.
//   // Возможным значением объекта является 'undefined'
// })



// ! Правило: при написании типа функции для колбека, 
// не указывайте опциональные параметры до тех пор, 
// пока не будете вызывать функцию без передачи этих параметров.







// 7) Перегрузка функции (function overload)

// Некоторые функции могут вызываться с разным количеством аргументов. 
// Например, мы можем написать функцию, возвращающую Date, 
// которая принимает время в мс (timestamp, один аргумент) или день/месяц/год (три аргумента).

// В TS такую функцию можно реализовать с помощью сигнатур перегрузки (overload signatures). 
// Для этого перед телом функции указывается несколько ее сигнатур:

// function makeDate(timestamp: number): Date
// function makeDate(d: number, m: number, y: number): Date
// function makeDate(dOrTimestamp: number, m?: number, y?: number): Date {
//   if (m !== undefined && y !== undefined) {
//     return new Date(y, m, dOrTimestamp)
//   } else {
//     return new Date(dOrTimestamp)
//   }
// }



// const d1 = makeDate(12345678)
// const d2 = makeDate(5, 5, 5)
// const d3 = makeDate(1, 3)
// Нет перегрузки, принимающей 2 аргумента, 
// но существуют перегрузки, ожидающие получения 1 или 3 аргумента

// В приведенном примере мы реализовали две перегрузки: 
// одну, принимающую один аргумент, и вторую, принимающую три аргумента. 
// Первые две сигнатуры называются сигнатурами перегрузки.

// Затем мы реализовали функцию с совместимой сигнатурой (compatible signature).
// Функции имеют сигнатуру реализации (implementation signature), 
// но эта сигнатура не может вызываться напрямую. 
// Несмотря на то, что мы написали функцию с двумя опциональными параметрами 
// после обязательного, она не может вызываться с двумя параметрами!



// 7.1) Сигнатуры перегрузки и сигнатура реализации 
// (overload signatures and the implementation signature)

// Предположим, что у нас имеется такой код:
// function fn(x: string): void
// function fn() {
//   // ...
// }
// Мы ожидаем, что функция может вызываться без аргументов
// fn()
// Ожидалось получение 1 аргумента, а получено 0


// Почему в данном случае возникает ошибка? 
// Дело в том, что сигнатура реализации не видна снаружи (за пределами тела функции). 
// Поэтому при написании перегруженной функции всегда нужно указывать две 
// или более сигнатуры перегрузки перед сигнатурой реализации.

// Кроме того, сигнатура реализации должна быть совместима с сигнатурами перегрузки. 
// Например, при вызове следующих функций возникают ошибки, 
// поскольку сигнатура реализации не совпадает с сигнатурами перегрузки:

// function fn(x: boolean): void
// Неправильный тип аргумента
// function fn(x: string): void
// Данная сигнатура перегрузки не совместима с сигнатурой ее реализации
// function(x: boolean) {}
// function fn(x: string): string
// Неправильный тип возвращаемого значения
// function(x: number): boolean
// This overload signature is not compatible with its implementation signature.
// function fn(x: string | number) {
//   return 'упс'
// }



// 7.2) Правила реализации хороших перегрузок функции

// Рассмотрим функцию, возвращающую длину строки или массива:
// function len(s: string): number
// function len(arr: any[]): number
// function len(x: any) {
//   return x.length
// }

// На первый взгляд кажется, что все в порядке. 
// Мы можем вызывать функцию со строками или массивами. 
// Однако, мы не можем вызывать ее со значением, 
// которое может быть либо строкой, либо массивом, 
// поскольку TS ассоциирует вызов функции с одной из ее перегрузок:

// len('') // OK
// len([0]) // OK
// len(Math.random() > 0.5 ? 'привет' : [0])
/*
Ни одна из перегрузок не совпадает с вызовом.
  Перегрузка 1 из 2, '(s: string): number', возвращает следующую ошибку.
    Аргумент типа 'number[] | "привет"' не может быть присвоен параметру типа 'string'.
      Тип 'number[]' не может быть присвоен типу 'string'.
  Перегрузка 2 из 2, '(arr: any[]): number', возвращает следующую ошибку.
    Аргумент типа 'number[] | "привет"' не может быть присвоен типу 'any[]'.
      Тип 'string' не может быть присвоен типу 'any[]'.
*/


// Поскольку обе перегрузки имеют одинаковое количество аргументов 
// и один и тот же тип возвращаемого значения, 
// мы можем реализовать такую "неперегруженную" версию данной функции:

// function len(x: any[] | string) {
//   return x.length
// }

// Теперь мы можем вызывать функцию с любым значением и, кроме того, 
// нам не нужно предварительно определять правильную сигнатуру реализации функцию.

// ! Правило: по-возможности используйте объединения вместо перегрузок функции.







// 8) Определение this в функциях

// Рассмотрим пример:
// const user = {
//   id: 123,

//   admin: false,

//   becomeAdmin: function () {
//     this.admin = true
//   }
// }

// TS "понимает", что значением this функции user.becomeAdmin 
// является внешний объект user. 
// В большинстве случаев этого достаточно, 
// но порой нам требуется больше контроля над тем, 
// что представляет собой this. 

// Спецификация JS определяет, что мы не можем использовать this 
// в качестве названия параметра. TS использует это синтаксическое пространство 
// (syntax space), позволяя определять тип this в теле функции:

// const db = getDB()
// const admins = db.filterUsers(function () {
//   return this.admin
// })

// В данном случае мы не можем использовать стрелочную функцию.

// const db = getDB()
// const admins = db.filterUsers(() => this.admin)
// Стрелочная функция перехватывает глобальное значение 'this'. 
// Неявным типом элемента является 'any', 
// поскольку тип 'typeof globalThis' не имеет сигнатуры индекса


function App() {
  return (
    <div>

    </div>
  );
}

export default App;
